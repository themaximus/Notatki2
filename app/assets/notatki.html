<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Умная Доска Задач v5.2 - Полный JS</title>
  <style>
    :root {
      --bg-main: #2c3e50;
      --bg-elements: #34495e;
      --bg-elements-lighter: #4a627a;
      --bg-sidebar: #314354;
      --bg-subtask: #3e576f;
      --text-primary: #ecf0f1;
      --text-secondary: #bdc3c7;
      --text-timestamp: #95a5a6;
      --accent-primary: #3498db;
      --accent-secondary: #2ecc71;
      --accent-danger: #e74c3c;
      --accent-warning: #f39c12;

      --shadow-color-dark: rgba(0,0,0,0.2);
      --shadow-color-light: rgba(255,255,255,0.05);

      --border-radius-main: 12px;
      --border-radius-small: 8px;

      --priority-high-color: #e74c3c;
      --priority-medium-color: #f39c12;
      --priority-low-color: #2ecc71;

      --sidebar-width: 300px;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: 'Segoe UI', 'Roboto', Arial, sans-serif;
      background-color: var(--bg-main);
      background-image: linear-gradient(45deg, rgba(0,0,0,0.03) 25%, transparent 25%, transparent 50%, rgba(0,0,0,0.03) 50%, rgba(0,0,0,0.03) 75%, transparent 75%, transparent);
      background-size: 30px 30px;
      color: var(--text-primary);
      line-height: 1.6;
      transition: background-color 0.3s;
      overflow-x: hidden;
    }

    .visually-hidden {
      position: absolute;
      width: 1px;
      height: 1px;
      margin: -1px;
      padding: 0;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      border: 0;
    }

    .overlay {
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background-color: rgba(0,0,0,0.5); opacity: 0; visibility: hidden;
      z-index: 999; transition: opacity 0.3s ease, visibility 0s linear 0.3s;
    }
    .overlay.active { opacity: 1; visibility: visible; transition: opacity 0.3s ease; }

    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.6);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1001;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.3s ease, visibility 0s linear 0.3s;
    }
    .modal-overlay.active {
      opacity: 1;
      visibility: visible;
      transition: opacity 0.3s ease;
    }
    .modal-dialog {
      background-color: var(--bg-elements);
      padding: 25px;
      border-radius: var(--border-radius-main);
      box-shadow: 0 5px 20px rgba(0,0,0,0.3);
      width: 90%;
      max-width: 400px;
      text-align: center;
      transform: scale(0.9);
      transition: transform 0.3s ease;
    }
    .modal-overlay.active .modal-dialog {
        transform: scale(1);
    }
    .modal-dialog p {
      margin-bottom: 20px;
      font-size: 1.1rem;
      color: var(--text-primary);
    }
    .modal-buttons button {
      padding: 0.6rem 1rem;
      border: none;
      border-radius: var(--border-radius-small);
      font-size: 0.9rem;
      font-weight: 500;
      cursor: pointer;
      transition: background-color 0.2s;
      min-width: 100px;
      margin: 0 8px;
    }
    #customConfirmOk {
      background-color: var(--accent-danger);
      color: white;
    }
    #customConfirmOk:hover {
      background-color: #c0392b;
    }
    #customConfirmCancel {
      background-color: var(--bg-elements-lighter);
      color: var(--text-primary);
    }
    #customConfirmCancel:hover {
      background-color: var(--bg-sidebar);
    }

    /* Полные стили CSS из вашего оригинального файла */
    .sidebar {
      position: fixed; top: 0; left: calc(-1 * var(--sidebar-width));
      width: var(--sidebar-width); height: 100vh; background-color: var(--bg-sidebar);
      box-shadow: 4px 0 15px rgba(0,0,0,0.25); z-index: 1000; display: flex;
      flex-direction: column; padding: 1.5rem 1rem; transition: left 0.3s ease-in-out;
    }
    .sidebar.active { left: 0; }
    .sidebar-header {
      display: flex; justify-content: space-between; align-items: center;
      margin-bottom: 1.5rem; padding-bottom: 1rem; border-bottom: 1px solid var(--bg-elements-lighter);
    }
    .sidebar-header h3 { font-size: 1.4rem; color: var(--text-primary); font-weight: 500; }

    .btn-icon {
        background: transparent; border: none; color: var(--text-secondary);
        font-size: 1.2rem;
        cursor: pointer; padding: 0.3rem; line-height: 1;
        border-radius: 50%; width: 32px;
        height: 32px;
        display: inline-flex;
        align-items: center; justify-content: center;
    }
    .btn-icon:hover { background-color: var(--bg-elements-lighter); color: var(--text-primary); }

    .board-list { list-style: none; flex-grow: 1; overflow-y: auto; margin-bottom: 1rem; }
    .board-list-item {
      padding: 0.75rem 1rem; margin-bottom: 0.5rem; border-radius: var(--border-radius-small);
      color: var(--text-secondary); cursor: pointer; transition: background-color 0.2s, color 0.2s;
      font-size: 1rem; display: flex; justify-content: space-between; align-items: center;
    }
    .board-list-item:hover { background-color: var(--bg-elements-lighter); color: var(--text-primary); }
    .board-list-item.active-board { background-color: var(--accent-primary); color: #fff; font-weight: 500; }

    .board-item-controls {
        display: flex;
        align-items: center;
        gap: 0.25rem;
    }
    .board-list-item .btn-edit-board-name {
        color: var(--text-secondary);
        opacity: 0.7;
    }
     .board-list-item:hover .btn-edit-board-name {
        opacity: 1;
        color: var(--accent-warning);
    }
    .board-list-item.active-board .btn-edit-board-name {
        color: rgba(255,255,255,0.7);
    }
    .board-list-item.active-board .btn-edit-board-name:hover {
        color: #fff;
        background-color: rgba(0,0,0,0.2);
    }

    .board-list-item .btn-delete-board-item {
        color: var(--text-secondary);
        opacity: 0.7;
    }
    .board-list-item:hover .btn-delete-board-item { opacity: 1; color: var(--accent-danger); }
    .board-list-item.active-board .btn-delete-board-item { color: rgba(255,255,255,0.7); }
    .board-list-item.active-board .btn-delete-board-item:hover { color: #fff; background-color: rgba(0,0,0,0.2); }

    .sidebar-footer { padding-top: 1rem; border-top: 1px solid var(--bg-elements-lighter); }
    #newBoardNameInput {
      width: 100%; padding: 0.7rem; margin-bottom: 0.75rem; border-radius: var(--border-radius-small);
      border: 1px solid var(--bg-elements-lighter); background-color: var(--bg-elements);
      color: var(--text-primary); font-size: 0.9rem;
    }
    #newBoardNameInput::placeholder { color: var(--text-secondary); }
    #addBoardBtn { width: 100%; background-color: var(--accent-secondary); color: #fff; }
    #addBoardBtn:hover { background-color: #27ae60; }

    header {
      padding: 1rem 2rem;
      background: var(--bg-elements);
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      font-size: 1.6rem;
      font-weight: 600;
      color: var(--text-primary);
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
      border-bottom: 1px solid var(--bg-elements-lighter);
      position: relative;
      z-index: 10;
    }
    .app-title {
      display: flex; align-items: center; gap: 0.75rem; font-weight: 500; cursor: pointer;
      padding: 0.25rem 0.5rem; border-radius: var(--border-radius-small); transition: background-color 0.2s;
    }
    .app-title:hover { background-color: var(--bg-elements-lighter); }
    .app-title svg { width: 28px; height: 28px; fill: var(--accent-primary); }

    .btn {
      padding: 0.7rem 1.2rem; border: none; border-radius: var(--border-radius-small);
      font-size: 0.95rem; font-weight: 500; cursor: pointer; transition: all 0.2s ease-in-out;
      background-color: var(--bg-elements-lighter); color: var(--text-primary);
      box-shadow: 3px 3px 6px var(--shadow-color-dark), -3px -3px 6px var(--shadow-color-light);
      display: inline-flex; align-items: center; gap: 0.5rem;
    }
    .btn svg { width: 16px; height: 16px; fill: currentColor; }
    .btn:hover { background-color: var(--accent-primary); color: #fff; }
    .btn:active { box-shadow: inset 3px 3px 6px var(--shadow-color-dark), inset -3px -3px 6px var(--shadow-color-light); transform: translateY(1px); }
    .btn-add-column { background-color: var(--accent-secondary); color: #fff; }

    .board {
      display: flex; gap: 1.5rem; padding: 1.5rem; overflow-x: auto;
      flex-wrap: nowrap; min-height: calc(100vh - 75px);
      align-items: flex-start;
    }
    .column {
      background: var(--bg-elements); border-radius: var(--border-radius-main);
      padding: 1rem 1.2rem; width: 340px; min-width: 340px;
      box-shadow: 5px 5px 15px var(--shadow-color-dark), -5px -5px 10px var(--shadow-color-light);
      display: flex; flex-direction: column; transition: box-shadow 0.3s ease;
    }
    .column-header {
      display: flex; justify-content: space-between; align-items: center;
      margin-bottom: 1rem; padding-bottom: 0.75rem; border-bottom: 1px solid var(--bg-elements-lighter);
    }
    .column-title-input {
      font-size: 1.2rem; font-weight: 600; border: none; background: transparent;
      color: var(--text-primary); outline: none; flex-grow: 1; padding: 0.4rem;
      border-radius: var(--border-radius-small);
    }
    .btn-delete {
        background: transparent; color: var(--text-secondary); padding: 0.4rem;
        border-radius: 50%; box-shadow: none; width: 36px; height: 36px;
        display: flex; align-items: center; justify-content: center;
        border: none;
    }
    .btn-delete svg { width: 18px; height: 18px; fill: currentColor; }
    .btn-delete:hover { background-color: var(--accent-danger); color: #fff; }

    .tasks-list {
      flex-grow: 1; min-height: 60px; display: flex; flex-direction: column;
      gap: 1rem; overflow-y: auto; padding-right: 8px; margin-right: -8px;
    }
    .tasks-list::-webkit-scrollbar { width: 8px; }
    .tasks-list::-webkit-scrollbar-track { background: var(--bg-elements); border-radius: 10px; }
    .tasks-list::-webkit-scrollbar-thumb { background: var(--bg-elements-lighter); border-radius: 10px; }
    .tasks-list::-webkit-scrollbar-thumb:hover { background: var(--accent-primary); }

    .task {
      background: var(--bg-elements-lighter); border-radius: var(--border-radius-small);
      padding: 0.8rem 1rem; box-shadow: 3px 3px 8px var(--shadow-color-dark), -3px -3px 6px var(--shadow-color-light);
      display: flex; flex-direction: column; transition: all 0.2s ease-in-out;
      position: relative; border-left: 4px solid transparent;
    }
    .task.priority-high { border-left-color: var(--priority-high-color); }
    .task.priority-medium { border-left-color: var(--priority-medium-color); }
    .task.priority-low { border-left-color: var(--priority-low-color); }

    .task-main-content { margin-bottom: 0.5rem; }
    .task textarea {
      border: none; resize: none; background: transparent; outline: none;
      width: 100%; font-size: 0.95rem; line-height: 1.5; color: var(--text-primary);
      white-space: pre-wrap; overflow-wrap: break-word; min-height: 40px;
      border-radius: 4px; padding: 0.2rem;
    }
    .task-timestamp { font-size: 0.75rem; color: var(--text-timestamp); text-align: right; margin-top: 0.25rem; }
    .task.task-done { opacity: 0.7; background-color: #3a5064; }
    .task.task-done textarea { text-decoration: line-through; color: var(--text-secondary); }

    .task-footer { display: flex; justify-content: space-between; align-items: center; margin-top: 0.5rem; gap: 0.5rem; }
    .task-controls { display: flex; align-items: center; gap: 0.75rem;  }
    .priority-selector-container { display: flex; align-items: center; gap: 0.3rem; }
    .priority-dot { width: 10px; height: 10px; border-radius: 50%; background-color: var(--text-secondary); }
    .priority-dot.high { background-color: var(--priority-high-color); }
    .priority-dot.medium { background-color: var(--priority-medium-color); }
    .priority-dot.low { background-color: var(--priority-low-color); }
    .priority-selector {
        padding: 0.3rem 0.5rem; border-radius: var(--border-radius-small); background: var(--bg-elements);
        color: var(--text-primary); border: 1px solid var(--bg-elements-lighter); font-size: 0.85rem;
        box-shadow: 1px 1px 3px var(--shadow-color-dark), -1px -1px 2px var(--shadow-color-light);
        cursor: pointer; appearance: none;
        background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%23bdc3c7'%3E%3Cpath d='M7 10l5 5 5-5z'/%3E%3C/svg%3E");
        background-repeat: no-repeat; background-position: right 0.5rem center; background-size: 1em;
        padding-right: 1.8rem;
    }
    .btn-add-task-in-column { margin-top: 1rem; background-color: var(--accent-primary); color: #fff; width: 100%; }
    .task.dragging { opacity: 0.6; transform: rotate(2deg) scale(1.03); background-color: var(--accent-primary); }
    input[type="checkbox"] {
      width: 18px; height: 18px; accent-color: var(--accent-secondary); cursor: pointer;
      border-radius: 4px; margin-right: 0.25rem; vertical-align: middle;
    }

    .subtasks-section { margin-top: 0.75rem; padding-top: 0.75rem; border-top: 1px dashed var(--bg-elements); }
    .subtasks-header {
        display: flex; justify-content: space-between; align-items: center;
        margin-bottom: 0.5rem; cursor: pointer;
    }
    .subtasks-header h4 { font-size: 0.9rem; color: var(--text-secondary); font-weight: 500; }
    .subtasks-toggle-icon { transition: transform 0.2s ease-in-out; color: var(--text-secondary); }
    .subtasks-list.collapsed + .subtasks-header .subtasks-toggle-icon { transform: rotate(-90deg); }
    .subtasks-list {
        list-style: none; padding-left: 1rem; max-height: 200px; overflow-y: auto;
        transition: max-height 0.3s ease-in-out, opacity 0.3s ease-in-out; opacity: 1;
    }
    .subtasks-list.collapsed { max-height: 0; opacity: 0; overflow: hidden; margin-top: 0; }
    .subtask-item {
        background-color: var(--bg-subtask); padding: 0.5rem 0.75rem;
        border-radius: var(--border-radius-small); margin-bottom: 0.5rem;
        display: flex; align-items: center; gap: 0.5rem;
    }
    .subtask-item input[type="text"] {
        flex-grow: 1; background: transparent; border: none; color: var(--text-primary);
        font-size: 0.9rem; outline: none;
    }
    .subtask-item input[type="text"].done { text-decoration: line-through; color: var(--text-secondary); opacity: 0.7; }
    .subtask-item .btn-delete-subtask {
        font-size: 0.9rem; padding: 0.2rem; color: var(--text-secondary);
        background: none; border: none; cursor: pointer;
    }
    .subtask-item .btn-delete-subtask:hover { color: var(--accent-danger); }
    .btn-add-subtask {
        font-size: 0.85rem; padding: 0.3rem 0.6rem; color: var(--accent-primary);
        background-color: transparent; border: 1px dashed var(--accent-primary);
        border-radius: var(--border-radius-small); margin-top: 0.5rem;
        display: inline-flex; align-items: center; gap: 0.3rem;
    }
    .btn-add-subtask:hover { background-color: rgba(52, 152, 219, 0.1); color: var(--text-primary); }

    @media (max-width: 768px) {
      header {
        padding: 1rem;
        gap: 0.8rem;
      }
      .app-title {
        font-size: 1.4rem;
      }
      .btn-add-column {
        white-space: nowrap;
      }
      .board { flex-direction: column; padding: 1rem; gap: 1rem; }
      .column { width: 100%; min-width: unset; }
      :root { --sidebar-width: 260px; }
    }
  </style>
</head>
<body>
<div class="overlay" id="overlay"></div>
<div class="sidebar" id="sidebar">
  <div class="sidebar-header">
    <h3>Мои Доски</h3>
    <button id="closeSidebarBtn" class="btn-icon" title="Закрыть панель">&times;</button>
  </div>
  <ul class="board-list" id="boardList"></ul>
  <div class="sidebar-footer">
    <label for="newBoardNameInput" class="visually-hidden">Название новой доски</label>
    <input type="text" id="newBoardNameInput" placeholder="Название новой доски...">
    <button id="addBoardBtn" class="btn">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M19 11h-6V5h-2v6H5v2h6v6h2v-6h6z"/></svg>
      Создать Доску
    </button>
  </div>
</div>

<header>
  <div class="app-title" id="appTitleButton" title="Открыть список досок">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M19 3H5c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2h14c1.103 0 2-.897 2-2V5c0-1.103-.897-2-2-2zM5 19V5h14l.002 14H5z"/><path d="M7 7h10v2H7zm0 4h7v2H7z"/></svg>
    <span id="currentBoardTitle">Моя Умная Доска</span>
  </div>
  <button class="btn btn-add-column" onclick="addColumnToCurrentBoard()">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 11h-6V5h-2v6H5v2h6v6h2v-6h6z"/></svg>
    Добавить колонку
  </button>
</header>
<div class="board" id="boardContainer"></div>

<div class="modal-overlay" id="customConfirmModal">
  <div class="modal-dialog">
    <p id="customConfirmMessage">Вы уверены?</p>
    <div class="modal-buttons">
      <button id="customConfirmCancel">Отмена</button>
      <button id="customConfirmOk">Удалить</button>
    </div>
  </div>
</div>

<script>
  // --- КОНСТАНТЫ и ГЛОБАЛЬНЫЕ ПЕРЕМЕННЫЕ ---
  const LS_ALL_BOARDS_KEY = 'smartKanbanAllBoards_v4_native';
  const LS_ACTIVE_BOARD_ID_KEY = 'smartKanbanActiveBoardId_v4_native';
  const WIDGET_BOARD_NAME_JS = "Заметки Виджета";

  const ICONS = {
      delete: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"/></svg>`,
      add: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"/></svg>`,
      subtaskToggle: `<svg class="subtasks-toggle-icon" xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4.646 1.646a.5.5 0 0 1 .708 0l6 6a.5.5 0 0 1 0 .708l-6 6a.5.5 0 0 1-.708-.708L10.293 8 4.646 2.354a.5.5 0 0 1 0-.708z"/></svg>`,
      edit: `✏️`
  };

  let allBoardsData = {};
  let activeBoardId = null;
  let widgetBoardIdFromNative = null;
  let confirmCallback = null;

  // --- DOM ЭЛЕМЕНТЫ ---
  const boardContainer = document.getElementById('boardContainer');
  const sidebar = document.getElementById('sidebar');
  const overlay = document.getElementById('overlay');
  const appTitleButton = document.getElementById('appTitleButton');
  const closeSidebarBtn = document.getElementById('closeSidebarBtn');
  const boardListEl = document.getElementById('boardList');
  const newBoardNameInput = document.getElementById('newBoardNameInput');
  const addBoardBtn = document.getElementById('addBoardBtn');
  const currentBoardTitleEl = document.getElementById('currentBoardTitle');
  const customConfirmModal = document.getElementById('customConfirmModal');
  const customConfirmMessage = document.getElementById('customConfirmMessage');
  const customConfirmOkBtn = document.getElementById('customConfirmOk');
  const customConfirmCancelBtn = document.getElementById('customConfirmCancel');

  // --- РЕАЛИЗАЦИЯ ВСЕХ ФУНКЦИЙ ---

  function generateId(prefix = 'id') { return `${prefix}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`; }

  function isNativeBridgeAvailable() { return typeof window.AndroidNative !== 'undefined'; }

  function showCustomConfirm(message, callback) {
      customConfirmMessage.textContent = message;
      confirmCallback = callback;
      customConfirmModal.classList.add('active');
  }

  function hideCustomConfirm() {
      customConfirmModal.classList.remove('active');
      confirmCallback = null;
  }

  function toggleSidebar() { sidebar.classList.toggle('active'); overlay.classList.toggle('active'); }

  function loadAllBoardsFromLocalStorage() {
      console.log('[DEBUG] loadAllBoardsFromLocalStorage: Загрузка всех досок из localStorage');
      const data = localStorage.getItem(LS_ALL_BOARDS_KEY);
      allBoardsData = data ? JSON.parse(data) : {};
      console.log('[DEBUG] loadAllBoardsFromLocalStorage: Загруженные данные:', JSON.parse(JSON.stringify(allBoardsData)));
  }

  function saveAllBoardsToLocalStorage() {
      const boardsToSave = {};
      for (const boardId in allBoardsData) {
          if (allBoardsData[boardId] && !allBoardsData[boardId].isWidgetBoard) {
              boardsToSave[boardId] = allBoardsData[boardId];
          }
      }
      console.log('[DEBUG] saveAllBoardsToLocalStorage: Сохранение не-виджетных досок. Данные:', JSON.parse(JSON.stringify(boardsToSave)));
      localStorage.setItem(LS_ALL_BOARDS_KEY, JSON.stringify(boardsToSave));
      console.log('[DEBUG] saveAllBoardsToLocalStorage: Данные сохранены.');
  }

  function loadActiveBoardId() {
      activeBoardId = localStorage.getItem(LS_ACTIVE_BOARD_ID_KEY);
      console.log('[DEBUG] loadActiveBoardId: Загружен activeBoardId из LS:', activeBoardId);
  }

  function saveActiveBoardId() {
      console.log('[DEBUG] saveActiveBoardId: Сохранение activeBoardId в LS:', activeBoardId);
      if (activeBoardId) {
          localStorage.setItem(LS_ACTIVE_BOARD_ID_KEY, activeBoardId);
      } else {
          localStorage.removeItem(LS_ACTIVE_BOARD_ID_KEY);
      }
  }

  function updateCurrentBoardTitle() {
      let title = "Моя Умная Доска";
      if (activeBoardId === widgetBoardIdFromNative && isNativeBridgeAvailable()) {
          title = (allBoardsData[widgetBoardIdFromNative] && allBoardsData[widgetBoardIdFromNative].name)
                  ? allBoardsData[widgetBoardIdFromNative].name
                  : WIDGET_BOARD_NAME_JS;
      } else if (activeBoardId && allBoardsData[activeBoardId] && allBoardsData[activeBoardId].name) {
          title = allBoardsData[activeBoardId].name;
      }
      currentBoardTitleEl.textContent = title;
      console.log('[DEBUG] updateCurrentBoardTitle: Установлен заголовок:', title);
  }

  function renderBoardList() {
      boardListEl.innerHTML = '';
      const tempAllBoardsForList = { ...allBoardsData };

      if (widgetBoardIdFromNative && !tempAllBoardsForList[widgetBoardIdFromNative]) {
          tempAllBoardsForList[widgetBoardIdFromNative] = { id: widgetBoardIdFromNative, name: WIDGET_BOARD_NAME_JS, columns: [], isWidgetBoard: true };
      }

      const boardIdsToRender = Object.keys(tempAllBoardsForList);

      if (boardIdsToRender.length === 0) {
          boardListEl.innerHTML = '<li style="padding: 0.75rem 1rem; color: var(--text-secondary);">Нет досок. Создайте новую!</li>';
          return;
      }

      boardIdsToRender.sort((a, b) => {
          const aIsWidget = a === widgetBoardIdFromNative;
          const bIsWidget = b === widgetBoardIdFromNative;
          if (aIsWidget && !bIsWidget) return -1;
          if (!aIsWidget && bIsWidget) return 1;
          return (tempAllBoardsForList[a].name || "").localeCompare(tempAllBoardsForList[b].name || "");
      }).forEach(boardId => {
          const boardData = tempAllBoardsForList[boardId];
          if (!boardData) return;

          const listItem = document.createElement('li');
          listItem.className = 'board-list-item';

          const boardNameSpan = document.createElement('span');
          boardNameSpan.textContent = boardData.name + (boardData.isWidgetBoard ? " (Виджет)" : "");
          boardNameSpan.style.flexGrow = "1";
          listItem.appendChild(boardNameSpan);

          listItem.dataset.boardId = boardId;
          if (boardId === activeBoardId) listItem.classList.add('active-board');

          listItem.addEventListener('click', (e) => {
              if (e.target.closest('button.btn-icon')) return;
              switchBoard(boardId);
          });

          if (!boardData.isWidgetBoard) {
              const controlsContainer = document.createElement('div');
              controlsContainer.className = 'board-item-controls';
              const editBoardNameBtn = document.createElement('button');
              editBoardNameBtn.innerHTML = ICONS.edit;
              editBoardNameBtn.className = 'btn-icon btn-edit-board-name';
              editBoardNameBtn.title = 'Редактировать название доски';
              editBoardNameBtn.addEventListener('click', (e) => {
                  e.stopPropagation();
                  handleEditBoardName(boardId, boardData.name);
              });
              controlsContainer.appendChild(editBoardNameBtn);

              const deleteBoardItemBtn = document.createElement('button');
              deleteBoardItemBtn.innerHTML = '&times;';
              deleteBoardItemBtn.className = 'btn-icon btn-delete-board-item';
              deleteBoardItemBtn.title = `Удалить доску "${boardData.name}"`;
              deleteBoardItemBtn.addEventListener('click', (e) => {
                  e.stopPropagation();
                  handleDeleteBoard(boardId, boardData.name);
              });
              controlsContainer.appendChild(deleteBoardItemBtn);
              listItem.appendChild(controlsContainer);
          }
          boardListEl.appendChild(listItem);
      });
  }

  function handleEditBoardName(boardId, currentName) {
      const newName = prompt(`Введите новое название для доски "${currentName}":`, currentName);
      if (newName && newName.trim() !== '' && newName.trim() !== currentName) {
          const trimmedNewName = newName.trim();
          if (boardId === widgetBoardIdFromNative && isNativeBridgeAvailable()) {
              console.log(`[DEBUG] handleEditBoardName: Редактирование имени доски виджета ID: ${boardId} на "${trimmedNewName}" через AndroidNative`);
              AndroidNative.saveBoard(boardId, trimmedNewName, true);
              if(allBoardsData[boardId]) allBoardsData[boardId].name = trimmedNewName;
          } else {
              allBoardsData[boardId].name = trimmedNewName;
              saveAllBoardsToLocalStorage();
          }
          renderBoardList();
          if (boardId === activeBoardId) {
              updateCurrentBoardTitle();
          }
      } else if (newName !== null && newName.trim() === '') {
          alert("Название доски не может быть пустым.");
      }
  }

  function createNewBoard() {
      const boardName = newBoardNameInput.value.trim();
      if (!boardName) { alert("Пожалуйста, введите название для новой доски."); newBoardNameInput.focus(); return; }

      let newBoardId;
      const isWidget = false;

      if (isNativeBridgeAvailable()) {
          console.log(`[DEBUG] createNewBoard: Создание обычной доски "${boardName}" через AndroidNative`);
          newBoardId = AndroidNative.saveBoard(null, boardName, isWidget);
      } else {
          newBoardId = generateId('board');
      }

      allBoardsData[newBoardId] = {
          id: newBoardId,
          name: boardName,
          columns: [
              { id: generateId('col'), title: 'Запланировано 📝', tasks: [] },
              { id: generateId('col'), title: 'В процессе 🚀', tasks: [] },
              { id: generateId('col'), title: 'Готово 🎉', tasks: [] }
          ],
          isWidgetBoard: isWidget
      };

      if (!isNativeBridgeAvailable()) {
          saveAllBoardsToLocalStorage();
      }

      switchBoard(newBoardId);
      newBoardNameInput.value = '';
      if (sidebar.classList.contains('active')) toggleSidebar();
  }

  async function switchBoard(newBoardId) {
      console.log(`[DEBUG] switchBoard: Переключение на доску ID: ${newBoardId}. Текущая активная: ${activeBoardId}`);
      if (activeBoardId === newBoardId && boardContainer.children.length > 0 && document.getElementById('boardContainer').innerHTML.trim() !== '') {
           console.log(`[DEBUG] switchBoard: Доска ${newBoardId} уже активна и загружена.`);
           if (sidebar.classList.contains('active')) toggleSidebar();
           return;
      }
      if (activeBoardId && activeBoardId !== widgetBoardIdFromNative) {
          saveCurrentBoardState();
      }
      activeBoardId = newBoardId;
      saveActiveBoardId();
      await loadBoard();
      if (sidebar.classList.contains('active')) toggleSidebar();
  }

  async function loadBoard() {
      console.log('[DEBUG] loadBoard: Загрузка доски. activeBoardId:', activeBoardId, "widgetBoardIdFromNative:", widgetBoardIdFromNative);
      boardContainer.innerHTML = '';

      if (!activeBoardId) {
          console.log('[DEBUG] loadBoard: activeBoardId is null. Попытка установить.');
          const boardKeysFromStorage = Object.keys(allBoardsData).filter(id => id !== widgetBoardIdFromNative && allBoardsData[id] && !allBoardsData[id].isWidgetBoard);
          if (widgetBoardIdFromNative) {
              activeBoardId = widgetBoardIdFromNative;
          } else if (boardKeysFromStorage.length > 0) {
              activeBoardId = boardKeysFromStorage[0];
          } else if (!isNativeBridgeAvailable()) {
              const defaultBoardId = generateId('board_ls_default');
              allBoardsData[defaultBoardId] = { id: defaultBoardId, name: "Моя первая доска (LS)", columns: [
                  { id: generateId('col_ls_default'), title: 'Сделать (LS)', tasks: [{id: generateId('task_ls_default'), content: 'Начать работу! (LS)', done: false, priority: 'medium', createdAt: new Date().toISOString(), subtasks: [] }]},
              ], isWidgetBoard: false};
              activeBoardId = defaultBoardId;
              saveAllBoardsToLocalStorage();
          } else {
               boardContainer.innerHTML = `<p style="text-align:center; padding: 2rem; color: var(--text-secondary);">Создайте или выберите доску.</p>`;
               updateCurrentBoardTitle();
               renderBoardList();
               return;
          }
          if (activeBoardId) saveActiveBoardId();
      }

      updateCurrentBoardTitle();
      renderBoardList();

      let currentBoardData;
      if (activeBoardId === widgetBoardIdFromNative && isNativeBridgeAvailable()) {
          console.log(`[DEBUG] loadBoard: Загрузка данных для доски виджета ID: ${activeBoardId} через AndroidNative.`);
          try {
              const notesJson = await AndroidNative.getNotesForBoard(activeBoardId);
              const notes = JSON.parse(notesJson);
              currentBoardData = {
                  id: widgetBoardIdFromNative,
                  name: (allBoardsData[widgetBoardIdFromNative] && allBoardsData[widgetBoardIdFromNative].name) || WIDGET_BOARD_NAME_JS,
                  isWidgetBoard: true,
                  columns: [{ id: widgetBoardIdFromNative + "_col", title: "Заметки Виджета", tasks: notes }]
              };
              if (!allBoardsData[activeBoardId]) {
                  allBoardsData[activeBoardId] = { ...currentBoardData };
                  renderBoardList();
              } else {
                  if(allBoardsData[activeBoardId].name !== currentBoardData.name) {
                      allBoardsData[activeBoardId].name = currentBoardData.name;
                      renderBoardList();
                  }
                  // Обновляем колонки и задачи для доски виджета в allBoardsData, чтобы они были актуальны
                  allBoardsData[activeBoardId].columns = currentBoardData.columns;
              }
              updateCurrentBoardTitle();
          } catch (e) {
              console.error("[DEBUG] loadBoard: Ошибка при загрузке заметок для доски виджета:", e);
              boardContainer.innerHTML = `<p style="text-align:center; padding: 2rem; color: var(--accent-danger);">Ошибка загрузки данных доски виджета.</p>`;
              return;
          }
      } else {
          console.log(`[DEBUG] loadBoard: Загрузка данных для доски ID: ${activeBoardId} из allBoardsData (localStorage).`);
          currentBoardData = allBoardsData[activeBoardId];
      }

      if (currentBoardData && currentBoardData.columns) {
          console.log('[DEBUG] loadBoard: Отображение колонок для доски ID:', activeBoardId, 'Колонки:', JSON.stringify(currentBoardData.columns, null, 2));
          currentBoardData.columns.forEach(colData => {
              const columnEl = createColumnElement(colData.id, colData.title, colData.tasks || []);
              if (columnEl) {
                  boardContainer.appendChild(columnEl);
              } else {
                  console.error("[DEBUG] loadBoard: createColumnElement вернул undefined для данных:", colData);
              }
          });
      } else {
          if (activeBoardId) {
               boardContainer.innerHTML = `<p style="text-align:center; padding: 2rem; color: var(--text-secondary);">Нет колонок для отображения на доске "${(allBoardsData[activeBoardId] && allBoardsData[activeBoardId].name) || activeBoardId}".</p>`;
          }
          console.warn('[DEBUG] loadBoard: Не удалось загрузить колонки для текущей доски. ID:', activeBoardId, 'currentBoardData:', currentBoardData);
      }
  }

  function addColumnToCurrentBoard() {
      console.log('[DEBUG] addColumnToCurrentBoard вызван. activeBoardId:', activeBoardId);
      if (activeBoardId === widgetBoardIdFromNative && isNativeBridgeAvailable()) {
          alert("Добавление колонок на доску виджета не поддерживается из этого интерфейса.");
          return;
      }
      if (!activeBoardId || !allBoardsData[activeBoardId] || (allBoardsData[activeBoardId] && allBoardsData[activeBoardId].isWidgetBoard)) {
          alert("Сначала выберите или создайте обычную доску (не для виджета)!");
          return;
      }
      const newCol = createColumnElement(null, 'Новая колонка', []);
      boardContainer.appendChild(newCol);
      const colTitleInput = newCol.querySelector('.column-title-input');
      if(colTitleInput) colTitleInput.focus();
      saveCurrentBoardState();
  }

  function createSubtaskElement(subtaskId, content = '', done = false, parentTaskId) {
      const subtaskItem = document.createElement('li');
      subtaskItem.className = 'subtask-item';
      subtaskItem.dataset.subtaskId = subtaskId || generateId('subtask');

      const checkbox = document.createElement('input');
      checkbox.type = 'checkbox'; checkbox.checked = done;

      const input = document.createElement('input');
      input.type = 'text'; input.value = content; input.placeholder = 'Новая подзадача...';
      if(done) input.classList.add('done');

      checkbox.addEventListener('change', () => {
          input.classList.toggle('done', checkbox.checked);
          saveCurrentBoardState();
      });
      input.addEventListener('input', saveCurrentBoardState);
      input.addEventListener('blur', saveCurrentBoardState);

      const deleteSubtaskBtn = document.createElement('button');
      deleteSubtaskBtn.innerHTML = '&times;'; deleteSubtaskBtn.className = 'btn-delete-subtask';
      deleteSubtaskBtn.title = 'Удалить подзадачу';
      deleteSubtaskBtn.addEventListener('click', () => {
          console.log(`[DEBUG] Удаление подзадачи ID: ${subtaskItem.dataset.subtaskId} из задачи ID: ${parentTaskId}`);
          subtaskItem.remove();
          saveCurrentBoardState();
      });

      subtaskItem.appendChild(checkbox); subtaskItem.appendChild(input); subtaskItem.appendChild(deleteSubtaskBtn);
      return subtaskItem;
  }

  function createTaskElement(id, content = '', done = false, priority = 'medium', createdAt, subtasksData = []) {
    const task = document.createElement('div');
    task.className = 'task';
    task.dataset.taskId = id || generateId('task');
    task.dataset.priority = priority;
    task.dataset.createdAt = createdAt || new Date().toISOString();
    if (done) task.classList.add('task-done');
    task.classList.add(`priority-${priority}`);
    task.draggable = true;

    task.addEventListener('dragstart', (e) => { task.classList.add('dragging'); e.dataTransfer.effectAllowed = 'move'; });
    task.addEventListener('dragend', () => { task.classList.remove('dragging'); saveCurrentBoardState(); });

    const taskMainContent = document.createElement('div'); taskMainContent.className = 'task-main-content';
    const textarea = document.createElement('textarea');
    textarea.value = content; textarea.rows = 3; textarea.placeholder = 'Введите описание задачи...';
    textarea.addEventListener('input', () => { textarea.style.height = 'auto'; textarea.style.height = textarea.scrollHeight + 'px'; saveCurrentBoardState(); });
    requestAnimationFrame(() => { if(textarea.isConnected) {textarea.style.height = 'auto'; textarea.style.height = textarea.scrollHeight + 'px';} });

    const timestampEl = document.createElement('div'); timestampEl.className = 'task-timestamp';
    const date = new Date(task.dataset.createdAt);
    timestampEl.textContent = `Создано: ${date.toLocaleDateString('ru-RU')} ${date.toLocaleTimeString('ru-RU', {hour: '2-digit', minute:'2-digit'})}`;
    taskMainContent.appendChild(textarea); taskMainContent.appendChild(timestampEl);
    task.appendChild(taskMainContent);

    const taskFooter = document.createElement('div'); taskFooter.className = 'task-footer';
    const taskControls = document.createElement('div'); taskControls.className = 'task-controls';
    const checkbox = document.createElement('input'); checkbox.type = 'checkbox'; checkbox.checked = done;
    checkbox.title = 'Отметить как выполненную';
    checkbox.addEventListener('change', () => { task.classList.toggle('task-done', checkbox.checked); saveCurrentBoardState(); });

    const priorityContainer = document.createElement('div'); priorityContainer.className = 'priority-selector-container';
    const priorityDot = document.createElement('div'); priorityDot.className = `priority-dot ${priority}`;
    const prioritySelector = document.createElement('select'); prioritySelector.className = 'priority-selector';
    prioritySelector.title = 'Установить приоритет';
    const priorities = { low: 'Низкий', medium: 'Средний', high: 'Высокий' };
    for (const pValue in priorities) {
      const option = document.createElement('option'); option.value = pValue; option.textContent = priorities[pValue];
      if (pValue === priority) option.selected = true; prioritySelector.appendChild(option);
    }
    prioritySelector.addEventListener('change', (e) => {
      task.classList.remove(`priority-${task.dataset.priority}`); priorityDot.classList.remove(task.dataset.priority);
      task.dataset.priority = e.target.value; task.classList.add(`priority-${e.target.value}`); priorityDot.classList.add(e.target.value);
      saveCurrentBoardState();
    });
    priorityContainer.appendChild(checkbox); priorityContainer.appendChild(priorityDot); priorityContainer.appendChild(prioritySelector);
    taskControls.appendChild(priorityContainer);

    const deleteBtn = document.createElement('button'); deleteBtn.innerHTML = ICONS.delete;
    deleteBtn.className = 'btn-delete btn-delete-task'; deleteBtn.title = 'Удалить задачу';
    deleteBtn.addEventListener('click', () => {
        const currentTaskId = task.dataset.taskId;
        console.log(`[DEBUG] Попытка удалить задачу ID: ${currentTaskId}`);
        showCustomConfirm('Вы уверены, что хотите удалить эту задачу?', async (confirmed) => {
            if (confirmed) {
                console.log(`[DEBUG] Задача ID: ${currentTaskId} - удаление подтверждено.`);
                const isWidgetTask = activeBoardId === widgetBoardIdFromNative;
                if (isWidgetTask && isNativeBridgeAvailable()) {
                    console.log(`[DEBUG] Удаление задачи ID: ${currentTaskId} с доски виджета через AndroidNative.`);
                    AndroidNative.deleteNote(currentTaskId, widgetBoardIdFromNative);
                }
                const parentTasksList = task.parentElement;
                task.remove();
                console.log(`[DEBUG] Задача ID: ${currentTaskId} - удалена из DOM. Задач в списке: ${parentTasksList ? parentTasksList.children.length : 'N/A'}`);
                saveCurrentBoardState();
                 if (isWidgetTask && isNativeBridgeAvailable()) {
                      await loadBoard();
                 }
            } else {
                console.log(`[DEBUG] Задача ID: ${currentTaskId} - удаление отменено.`);
            }
        });
    });

    taskFooter.appendChild(taskControls); taskFooter.appendChild(deleteBtn);
    task.appendChild(taskFooter);

    const subtasksSection = document.createElement('div'); subtasksSection.className = 'subtasks-section';
    const subtasksHeader = document.createElement('div'); subtasksHeader.className = 'subtasks-header';
    subtasksHeader.innerHTML = `<h4>Подзадачи</h4>${ICONS.subtaskToggle}`;
    const subtasksList = document.createElement('ul'); subtasksList.className = 'subtasks-list collapsed';
    subtasksHeader.addEventListener('click', () => { subtasksList.classList.toggle('collapsed'); });
    (subtasksData || []).forEach(subtask => {
        subtasksList.appendChild(createSubtaskElement(subtask.id, subtask.content, subtask.done, task.dataset.taskId));
    });
    const addSubtaskBtn = document.createElement('button'); addSubtaskBtn.className = 'btn-add-subtask';
    addSubtaskBtn.innerHTML = `${ICONS.add} Добавить подзадачу`;
    addSubtaskBtn.addEventListener('click', () => {
        const newSubtaskEl = createSubtaskElement(null, '', false, task.dataset.taskId);
        subtasksList.appendChild(newSubtaskEl);
        if (subtasksList.classList.contains('collapsed')) { subtasksList.classList.remove('collapsed'); }
        newSubtaskEl.querySelector('input[type="text"]').focus();
        saveCurrentBoardState();
    });
    subtasksSection.appendChild(subtasksHeader); subtasksSection.appendChild(subtasksList); subtasksSection.appendChild(addSubtaskBtn);
    task.appendChild(subtasksSection);
    return task;
  }

  function createColumnElement(id, title = 'Новая колонка', tasksData = []) {
    const column = document.createElement('div'); column.className = 'column';
    column.dataset.columnId = id || generateId('col');
    const columnHeader = document.createElement('div'); columnHeader.className = 'column-header';
    const titleInput = document.createElement('input'); titleInput.type = 'text'; titleInput.value = title;
    titleInput.className = 'column-title-input'; titleInput.title = 'Изменить название колонки';

    if (activeBoardId === widgetBoardIdFromNative && id === widgetBoardIdFromNative + "_col") {
        titleInput.disabled = true;
    } else {
      titleInput.addEventListener('input', saveCurrentBoardState);
      titleInput.addEventListener('blur', saveCurrentBoardState);
    }

    const deleteColumnBtn = document.createElement('button'); deleteColumnBtn.innerHTML = ICONS.delete;
    deleteColumnBtn.className = 'btn-delete btn-delete-column'; deleteColumnBtn.title = 'Удалить колонку';

    if (activeBoardId === widgetBoardIdFromNative && id === widgetBoardIdFromNative + "_col") {
        deleteColumnBtn.style.display = 'none';
    } else {
        deleteColumnBtn.addEventListener('click', () => {
            const currentColumnId = column.dataset.columnId;
            console.log(`[DEBUG] Попытка удалить колонку ID: ${currentColumnId}, Title: ${titleInput.value}`);

            let confirmationMessage = `Удалить колонку "${titleInput.value}"?`;
            if (tasksData && tasksData.length > 0) {
                confirmationMessage = `Колонка "${titleInput.value}" содержит задачи. Вы уверены, что хотите её удалить?`;
            }
            showCustomConfirm(confirmationMessage, (confirmed) => {
                if (confirmed) {
                    console.log(`[DEBUG] Колонка ID: ${currentColumnId} - удаление подтверждено.`);
                    console.log('[DEBUG] Количество колонок в boardContainer до remove:', boardContainer.children.length);
                    column.remove();
                    console.log('[DEBUG] Количество колонок в boardContainer после remove:', boardContainer.children.length);
                    saveCurrentBoardState();
                } else {
                    console.log(`[DEBUG] Колонка ID: ${currentColumnId} - удаление отменено.`);
                }
            });
        });
    }
    columnHeader.appendChild(titleInput); columnHeader.appendChild(deleteColumnBtn);

    const tasksListEl = document.createElement('div'); tasksListEl.className = 'tasks-list';
    tasksListEl.addEventListener('dragover', e => {
      e.preventDefault();
      const draggingTask = document.querySelector('.task.dragging');
      if (!draggingTask) return;
      const afterElement = getDragAfterElement(tasksListEl, e.clientY);
      if (afterElement == null) { tasksListEl.appendChild(draggingTask); }
      else { tasksListEl.insertBefore(draggingTask, afterElement); }
    });
    column.appendChild(columnHeader); column.appendChild(tasksListEl);
    (tasksData || []).forEach(taskData => {
      const taskEl = createTaskElement(taskData.id, taskData.content, taskData.done, taskData.priority, taskData.createdAt, taskData.subtasks);
      tasksListEl.appendChild(taskEl);
    });

    const addTaskBtn = document.createElement('button'); addTaskBtn.innerHTML = `${ICONS.add} Добавить задачу`;
    addTaskBtn.className = 'btn btn-add-task-in-column';
    addTaskBtn.addEventListener('click', () => {
      const newTask = createTaskElement(null, '', false, 'medium', new Date().toISOString(), []);
      tasksListEl.appendChild(newTask);
      const taskTextarea = newTask.querySelector('.task-main-content textarea');
      if(taskTextarea) { taskTextarea.focus(); requestAnimationFrame(() => { if(taskTextarea.isConnected) {taskTextarea.style.height = 'auto'; taskTextarea.style.height = taskTextarea.scrollHeight + 'px';} }); }
      saveCurrentBoardState();
    });
    column.appendChild(addTaskBtn);
    return column;
  }

  function getDragAfterElement(container, y) {
    const draggableElements = [...container.querySelectorAll('.task:not(.dragging)')];
    return draggableElements.reduce((closest, child) => {
      const box = child.getBoundingClientRect(); const offset = y - box.top - box.height / 2;
      if (offset < 0 && offset > closest.offset) { return { offset: offset, element: child }; }
      else { return closest; }
    }, { offset: Number.NEGATIVE_INFINITY }).element;
  }

  function saveCurrentBoardState() {
      console.log('[DEBUG] saveCurrentBoardState: Начало. activeBoardId:', activeBoardId);
      if (!activeBoardId) {
          console.warn('[DEBUG] saveCurrentBoardState: Нет активной доски. Сохранение прервано.');
          return;
      }

      const isWidget = activeBoardId === widgetBoardIdFromNative;

      if (isWidget && isNativeBridgeAvailable()) {
          console.log('[DEBUG] saveCurrentBoardState: Сохранение состояния доски виджета через AndroidNative.');
          const columnElements = Array.from(boardContainer.children);
          if (columnElements.length > 0) {
              const widgetColumnElement = columnElements[0];
              const tasksElements = Array.from(widgetColumnElement.querySelectorAll('.tasks-list > .task'));

              tasksElements.forEach((taskEl, index) => {
                  let noteId = taskEl.dataset.taskId;
                  if (!noteId) {
                      noteId = generateId('task');
                      taskEl.dataset.taskId = noteId;
                  }
                  const content = taskEl.querySelector('.task-main-content textarea').value;
                  const priority = taskEl.dataset.priority || 'medium';
                  const isDone = taskEl.classList.contains('task-done');

                  console.log(`[DEBUG] saveCurrentBoardState (widget): Сохранение заметки ID: ${noteId}, Content: ${content.substring(0,20)}...`);
                  AndroidNative.saveNote(widgetBoardIdFromNative, noteId, content, priority, isDone, index);
              });
              AndroidNative.requestWidgetUpdate(widgetBoardIdFromNative);
          }
      } else {
          if (!allBoardsData[activeBoardId]) {
               console.warn('[DEBUG] saveCurrentBoardState: Нет данных для обычной доски в allBoardsData. ID:', activeBoardId);
               return;
          }
          console.log('[DEBUG] saveCurrentBoardState: Сохранение состояния обычной доски в localStorage.');
          const columnsElements = Array.from(boardContainer.children);
          const columns = columnsElements.map(columnEl => {
              const columnId = columnEl.dataset.columnId || generateId('col');
              const columnTitle = columnEl.querySelector('.column-title-input').value;
              const tasksElements = Array.from(columnEl.querySelectorAll('.tasks-list > .task'));
              const tasks = tasksElements.map(taskEl => {
                  return {
                      id: taskEl.dataset.taskId || generateId('task'),
                      content: taskEl.querySelector('.task-main-content textarea').value,
                      done: taskEl.classList.contains('task-done'),
                      priority: taskEl.dataset.priority || 'medium',
                      createdAt: taskEl.dataset.createdAt || new Date().toISOString(),
                      subtasks: Array.from(taskEl.querySelectorAll('.subtask-item')).map(subtaskEl => ({
                          id: subtaskEl.dataset.subtaskId || generateId('subtask'),
                          content: subtaskEl.querySelector('input[type="text"]').value,
                          done: subtaskEl.querySelector('input[type="checkbox"]').checked
                      }))
                  };
              });
              return { id: columnId, title: columnTitle, tasks: tasks };
          });
          allBoardsData[activeBoardId].columns = columns;
          saveAllBoardsToLocalStorage();
      }
      console.log('[DEBUG] saveCurrentBoardState: Состояние сохранено.');
  }

  function handleDeleteBoard(boardIdToDelete, boardName) {
      console.log(`[DEBUG] handleDeleteBoard: Попытка удалить доску ID: ${boardIdToDelete}, Имя: ${boardName}`);
      showCustomConfirm(`Вы уверены, что хотите удалить доску "${boardName}"? Это действие необратимо.`, (confirmed) => {
          if (confirmed) {
              console.log('[DEBUG] handleDeleteBoard: Удаление доски подтверждено.');
              if (boardIdToDelete === widgetBoardIdFromNative && isNativeBridgeAvailable()) {
                  console.log('[DEBUG] handleDeleteBoard: Попытка удалить доску виджета через AndroidNative.');
                  AndroidNative.deleteBoard(boardIdToDelete);
                  delete allBoardsData[boardIdToDelete];
              } else {
                  delete allBoardsData[boardIdToDelete];
                  saveAllBoardsToLocalStorage();
              }

              if (activeBoardId === boardIdToDelete) {
                  const remainingBoardIds = Object.keys(allBoardsData).filter(id => id !== widgetBoardIdFromNative);
                  if (widgetBoardIdFromNative && (!allBoardsData[widgetBoardIdFromNative] || Object.keys(allBoardsData).length === 1 && allBoardsData[widgetBoardIdFromNative])) {
                      activeBoardId = widgetBoardIdFromNative;
                  } else if (remainingBoardIds.length > 0) {
                      activeBoardId = remainingBoardIds[0];
                  } else {
                      activeBoardId = widgetBoardIdFromNative;
                  }
                  saveActiveBoardId();
              }
              renderBoardList();
              loadBoard();
              console.log('[DEBUG] handleDeleteBoard: Список досок и доска перезагружены.');
          } else {
              console.log('[DEBUG] handleDeleteBoard: Удаление отменено пользователем.');
          }
      });
  }

  // --- ИНИЦИАЛИЗАЦИЯ ПРИЛОЖЕНИЯ ---
  async function initializeApp() {
      console.log("[DEBUG] initializeApp: Начало инициализации приложения.");
      if (isNativeBridgeAvailable()) {
          console.log("[DEBUG] initializeApp: AndroidNative доступен.");
          try {
              widgetBoardIdFromNative = await window.AndroidNative.getWidgetBoardId();
              console.log("[DEBUG] initializeApp: Получен widgetBoardIdFromNative:", widgetBoardIdFromNative);
          } catch (e) {
              console.error("[DEBUG] initializeApp: Ошибка при вызове AndroidNative.getWidgetBoardId():", e);
              widgetBoardIdFromNative = null;
          }
      } else {
          console.warn("[DEBUG] initializeApp: AndroidNative НЕ доступен.");
      }

      loadAllBoardsFromLocalStorage();
      loadActiveBoardId();

      if (!activeBoardId && widgetBoardIdFromNative) {
          activeBoardId = widgetBoardIdFromNative;
      } else if (!activeBoardId && Object.keys(allBoardsData).length > 0) {
          const nonWidgetBoardKeys = Object.keys(allBoardsData).filter(id => id !== widgetBoardIdFromNative);
          if (nonWidgetBoardKeys.length > 0) {
              activeBoardId = nonWidgetBoardKeys[0];
          } else if (widgetBoardIdFromNative) {
               activeBoardId = widgetBoardIdFromNative;
          }
      } else if (!activeBoardId && !widgetBoardIdFromNative && Object.keys(allBoardsData).length === 0) {
          if (!isNativeBridgeAvailable()) {
               console.log('[DEBUG] initializeApp: Досок нет, AndroidNative недоступен. Создание доски по умолчанию (LS).');
              const defaultBoardId = generateId('board_ls_default');
              allBoardsData[defaultBoardId] = { id: defaultBoardId, name: "Моя первая доска (LS)", columns: [
                  { id: generateId('col_ls_default'), title: 'Сделать (LS)', tasks: [{id: generateId('task_ls_default'), content: 'Начать работу! (LS)', done: false, priority: 'medium', createdAt: new Date().toISOString(), subtasks: [] }]},
              ], isWidgetBoard: false};
              activeBoardId = defaultBoardId;
              saveAllBoardsToLocalStorage();
          }
      }

      if (activeBoardId) {
          saveActiveBoardId();
      }

      await loadBoard();
      console.log("[DEBUG] initializeApp: Инициализация завершена.");
  }

  // --- ПРИВЯЗКА ОБРАБОТЧИКОВ И ЗАПУСК ---
  customConfirmOkBtn.addEventListener('click', () => {
      if (confirmCallback) confirmCallback(true);
      hideCustomConfirm();
  });
  customConfirmCancelBtn.addEventListener('click', () => {
      if (confirmCallback) confirmCallback(false);
      hideCustomConfirm();
  });
  customConfirmModal.addEventListener('click', (e) => {
      if (e.target === customConfirmModal) {
          if (confirmCallback) confirmCallback(false);
          hideCustomConfirm();
      }
  });
  appTitleButton.addEventListener('click', toggleSidebar);
  closeSidebarBtn.addEventListener('click', toggleSidebar);
  overlay.addEventListener('click', toggleSidebar);
  addBoardBtn.addEventListener('click', createNewBoard);
  newBoardNameInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') createNewBoard(); });

  // Вызов инициализации
  initializeApp();
</script>
</body>
</html>
